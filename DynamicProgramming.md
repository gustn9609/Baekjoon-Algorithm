# 다이나믹 프로그래밍

다이나믹프로그래밍(동적계획법)의 방식

- 탑다운
- 보텀업

## Why 다이나믹 프래그래밍
\
ex) 피보나치 수열

1 1 2 3 5 8 13 21 34 55 89

=> A(n+2) = A(n+1) + A(n) (A1,A2 = 1)

\
피보나치 함수 소스코드
```{.python}
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4)) // 출력 : 3
```

### **문제점**  

#### n이 커지면 커질수록 반복해서 호출하는 수가 많아진다
- f(6) = f(5) + f(4) = (f(4) + f(3)) + (f(3) + f(2)) = (f(3) + f(2)) + (f(2) + f(1)) + (f(2) + f(1)) + (f(1) + f(1)) = ...
- f(6) 하나만 봐도 f(3) 은 3번,  f(2)는 5번 호출된다. //n이 100000이면? (시간복잡도 : O(2^N))
 
## 다이나믹 프로그래밍의 사용 조건
1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 문제에서도 동일하다.

* 메모이제이션 기법이란?
* => 한 번 구현한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법

피보나치 수열 소스코드(재귀적)
```{.python}
# 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
d = [0] * 100

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))
```

다이나믹 프로그래밍 vs 퀵정렬(분할 정복 알고리즘)

공통점 : 큰 문제를 작게 나눠서 푼다.
차이점 : 다이나믹 프로그래밍은 문제들이 서로 영향을 미친다.

 퀵정렬 => 해결된 문제는 다시 해결하지 않는다.  
 다이나믹 프로그래밍 => 한 번 해결했던 문제를 다시한번 해결 (시간복잡도 : O(N))

 ***재귀함수의 문제점***
 - 재귀 함수를 사용하면 컴퓨터 시스템에서는 함수를 다시 호출했을 때 메모리 상에 적재되는 일련의 과정을 따라야 하므로 *오버헤드*가 발생할 수 있다.
>오버헤드란 ? 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다. 예를 들어 A라는 처리를 단순하게 실행한다면 10초 걸리는데, 안전성을 고려하고 부가적인 B라는 처리를 추가한 결과 처리시간이 15초 걸렸다면, ***오버헤드는 5초***가 된다.
- 재귀 함수 대신 반복문을 사용해 오버헤드를 줄일 수 있다.

## 탑다운 vs 보텀업
### 탑다운(Top-Down)
=> 재귀함수 이용 : 큰 문제를 해결하기 위해 작은 문제를 호출(하향식)
=> 메모이제이션은 탑다운에 국한되어 사용 (메모이제이션(결과 기록 그뿐) != 다이나믹 프로그래밍)
### 보텀업(Bottom-Up)
=> 반복문 사용 : 작은 문제부터 차근차근 답을 도출(상향식)

> 가능하다면 탑다운보다는 ***보텀업*** 방식을 구현하자!
> 시스템상 재귀함수의 스택 크기가 한정되어 있을 수 있다. => setrecursionlimit() 함수를 호출해 재귀 제한 완화 가능

After
'최단경로'의 플로이드 워셜' 알고리즘